#!/usr/bin/perl

use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/perl5";
use lib "$Bin/../share/perl5";


use Cwd;

use Getopt::Long;
use Pod::Usage;

use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;
use Panfish::PanfishConfigFactory;
use Panfish::FileJobDatabase;
use Panfish::FileUtil;
use Panfish::ForkExecutor;
use Panfish::SGEJobStateHashFactory;
use Panfish::JobState;

my $cmdLineParseResult = GetOptions ("statusofjobs=s"    => \$statusOfJobsArgValue,
                                     "jobstatusreport=s" => \$jobStatusReportArgValue,
                                     "statusofjobids=s"  => \$statusOfJobIdsArgValue,
                                     "help|?"            => \$helpArg,
                                     "verbose+"          => \$verboseArg,
                                     "man"               => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

my $logger = Panfish::Logger->new();

my $logFileHandle = undef;

my $fUtil = Panfish::FileUtil->new($logger);

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $writer = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$fUtil,$logger);
my $config = $configFactory->getPanfishConfig();
$logger->setLevelBasedOnVerbosity($verboseArg);

my $jobDb = Panfish::FileJobDatabase->new($reader,
                                      $config->getDatabaseDir(),$fUtil,$logger);

my $job;
my $line;
my $jobId;
my $taskId;

my $exitVal = 0;
my $state;
my $cwd = getcwd();

# prints out a summary report of all non failed, non completed
# jobs in Panfish Database
# Format of output
# Cluster  submitted  queued  batched  batchedandchummed  running  done  failed
# gordon_shadow.q
if (defined($jobStatusReportArgValue)){

    if ($jobStatusReportArgValue eq "list"){
         my @states = Panfish::JobState->getAllStates();
         my ($error,@cList) = $config->getClusterListAsArray();
         for (my $x = 0; $x < @cList; $x++){
              my $summaryHash = $jobDb->getHashtableSummaryForCluster($cList[$x]);
              for (my $y = 0; $y < @states; $y++){
                   print "$cList[$x].".$states[$y]."=".$summaryHash->{$states[$y]}."\n";
              }
         }
    }
    else {
       $logger->fatal("$jobStatusReportArgValue not valid output format for --jobstatusreport flag");
       exit(1);
    }
    exit(0);

}

# User wants us to look at file, extract job ids and 
# let them know if those jobs are completed or still 
# running
if (defined($statusOfJobsArgValue)){
  if ( ! -s $statusOfJobsArgValue){
     $logger->fatal("$statusOfJobsArgValue is either not a file or is not of size greater then 0");
     print "status=".Panfish::JobState->UNKNOWN()."\n";
     exit(1);
  }

  my $res = $reader->openFile($statusOfJobsArgValue);
  if (defined($res)){
     $logger->fatal("Unable to open $statusOfJobsArgValue : $res");
     print "status=".Panfish::JobState->UNKNOWN()."\n";
     exit(1);
  }
  
  if ($config->getEngine() ne "SGE"){
     $logger->fatal("Only SGE engine currently supported. ".$config->getThisCluster()." is using ".
                    $config->getEngine());
     print "status=".Panfish::JobState->UNKNOWN()."\n";
     exit(1);
  }
  my $exec = Panfish::ForkExecutor->new();
  my $jobStatusFactory = Panfish::SGEJobStateHashFactory->new($config,$logger,$exec);

  my ($jobStatusHash,$err) = $jobStatusFactory->getJobStateHash();

  if (defined($err)){
    $logger->fatal("$err");
    exit(1);
  }

 
  my $status = Panfish::JobState->DONE();
  my $line = $reader->read();
  while(defined($line)){
    chomp($line);
    # parse out job id
    if ($line=~/Your .*has been submitted/){
       $line=~s/ \(.*//;
       $line=~s/^.* //;
       $line=~s/\..*//;
       my $jStatus = $jobStatusHash->{$line}; 
       if (defined($jStatus)){
          if ($jStatus ne Panfish::JobState->DONE() &&
              $jStatus ne Panfish::JobState->FAILED()){
             $status = Panfish::JobState->RUNNING();
             break;
          }
       }
    }
    $line = $reader->read();
  }
  $reader->close();
  print "status=$status\n";
  exit(0);
}

#
# User has passed in a set of job ids.  Assume
# they are comma delimited, parse and return
# status for each job as obtained from job database
#
if (defined($statusOfJobIdsArgValue)){
  my @jobs = split(",",$statusOfJobIdsArgValue);

  for (my $x = 0; $x < @jobs; $x++){
    my ($jobId,$taskId) = parseJobAndTaskId($jobs[$x]);
    $logger->debug("Parsed ".$jobs[$x]." to Job id: ".$jobId." task id: ".$taskId); 
    my $jobState = $jobDb->getJobStateByClusterAndId($config->getThisCluster(),$jobId,$taskId);
    print $jobs[$x]."=".$jobState."\n";    
  }



  exit(0);
}

#
# If no arguments were passed to command assume
# a list of job ids are being passed via stdin
# for each job obtain its status and output it to
# standard out
#
while(<STDIN>){
    chomp();
    $line = $_;
    # line should contain path to psub file
    # take this file and make a new job file using this as the command
    # write the command to a file using the job database
    # and print out the psub file minus .psub and path prefix.
     
    my ($jobId,$taskId) = parseJobAndTaskId($line);

    $logger->debug("Job id: ".$jobId." task id: ".$taskId); 

    my $jobState = $jobDb->getJobStateByClusterAndId($config->getThisCluster(),$jobId,$taskId);

    print $line."=".$jobState."\n";    
}  

#
# Given a job id in format ###.### or JOB_ID.TASK_ID parse
# out the JOB_ID and TASK_ID and return in two separate variables.
# If no '.' exists set $taskid below to empty string
#
# ie my ($jobid,$taskid) = parseJobAndTaskId($string);
#
sub parseJobAndTaskId {
  my $input = shift;
  my $jobId = undef;
  my $taskId = undef;
  if ($input=~/^(.*)\.(.*)$/){
        $jobId = $1;
        $taskId = $2;
  }
  else {
        $jobId = $input;
        $taskId = "";
  }   
  return ($jobId,$taskId);
}

    
exit($exitVal);
1;

__END__

=head1 NAME

panfishstat - Remote cluster Panfish stat

=head1 SYNOPSIS

panfishstat [ B<options> ]

=head1 DESCRIPTION

B<panfishstat> is run on remote cluster to check status of jobs

=head1 OPTIONS

=over 4

=item B<--statusofjobs file>

Takes output B<file> from B<cast> and returns status of jobs submitted by the B<cast> command.
The resulting output in a simple one line with this format

status=<JOBSTATUS>

where <JOBSTATUS> is either RUNNING, DONE, or UNKNOWN.

=item B<--statusofjobids ids>

Given a comma delimited list of job ids (ie JOB_ID.TASK_ID,JOB_ID.TASK_ID,...) This option
returns the status of these jobs as currently set in the B<Panfish> database.  The format:

JOB_ID.TASK_ID=<JOBSTATUS>

where <JOBSTATUS> is submitted, queued, batched, batchedandchummed, running, done, or failed

Please note that if the given job being queried is a shadow job id on current cluster, this status 
may show the job as completed, but it might still be running on SGE since the shadow job has not 
detected the change and exited.

=item B<--jobstatusreport type>

If set B<panfishstat> outputs a summary report of jobs.  The B<type> value defines format of
output.  Currently B<list> is the only supported format.

=item B<--verbose>

Verbose mode.  Causes B<panfishstat> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 2.

NOTE:  This is not an option in B<qsub>.

=back

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
