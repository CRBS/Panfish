#!/usr/bin/perl


use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/../lib";
use lib "$Bin/../lib/perl5/site_perl";
use lib "$Bin/../lib/perl5";

use Cwd;

use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;
use Panfish::PanfishConfigFactory;
use Panfish::Job;
use Panfish::JobState;
use Panfish::JobDatabase;

use Panfish::ForkExecutor;

my $SIGTERMCALLED = 0;
my $SIGUSR1CALLED = 0;

#catch the term signal and set a variable which will cause code to
#leave while loop gracefully
$SIG{TERM} = sub { $SIGTERMCALLED = 0; print stderr "Received TERM signal\n";};
$SIG{USR1} = sub { $SIGUSR1CALLED = 0; print stderr "Received USR1 signal\n";};


if (@ARGV == 0){
  pod2usage(2);
}


my $cmdLineParseResult = GetOptions ("e=s"      => \$eArgValue,
                                     "o=s"      => \$oArgValue,
                                     "dir=s"    => \$dirArgValue,
                                     "c=s"      => \$cArgValue,
                                     "verbose+" => \$verboseArg,
                                     "help|?"   => \$helpArg,
                                     "man"      => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

if (@ARGV < 1){
  pod2usage(2);
}


my $logger = Panfish::Logger->new();

if (!defined($verboseArg)){
  $logger->setLevel("ERROR");
}
else {
  if ($verboseArg == 1){
    $logger->setLevel("WARN");
  } elsif ($verboseArg == 2){
    $logger->setLevel("INFO");
  } elsif ($verboseArg == 3){
    $logger->setLevel("DEBUG");
  }
}

my $stderr = "";
my $stdout = "";

if (defined($eArgValue)){
    $stderr = $eArgValue;
}
else {
    $stderr = "need something here";
}
if (defined($oArgValue)){
    $stdout = $oArgValue;
}
else {
    $stdout = "need something here";
}

my $command = shift @ARGV;

my $readerWriter = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($readerWriter,$logger);
my $config = $configFactory->getPanfishConfig();

# Find the queue we are running under as well as job and task id
my $queue = $ENV{"QUEUE"};
my $jobId = $ENV{"JOB_ID"};
my $taskId = $ENV{"SGE_TASK_ID"};
my $jobName = $ENV{"JOB_NAME"};



$logger->debug("*********Panfish.config******\n".$config->getAllSetValues().
               "\n***************");

$logger->info("JobName:  $jobName");
$logger->info("Job.Task:  $jobId.$taskId");
$logger->info("Queue:  $queue");


# Write out the job file to the submit.dir/queue folder
my $JOBSTATE = Panfish::JobState->new();
my $job = Panfish::Job->new($queue,$jobId,$taskId,$jobName,getcwd(),$command,$JOBSTATE->SUBMITTED());
my $jobDb = Panfish::JobDatabase->new($readerWriter,$config->getSubmitDir(),$logger);

my $res = $jobDb->insert($job);

if (defined($res)){
   $logger->error("Unable to update job state: $res");
   exit(1);
}

#
my $sleepTime = $config->getLineSleepTime();



# Wait for the above file to move into done or failed directory
$job = getJob($jobDb,$sleepTime,$logger,$queue,$jobId,$taskId);
$logger->debug("Before loop");

while ($job->getState() ne $JOBSTATE->DONE() &&
       $job->getState() ne $JOBSTATE->FAILED()){
       
    $logger->debug("in while loop");
    handleSignal($logger);

    $logger->debug("Sleeping $sleepTime seconds cause job state is: ".
                   $job->getState()." and not either ".$JOBSTATE->DONE().
                   " or ".$JOBSTATE->FAILED());

    sleep $sleepTime;

    handleSignal($logger);

    $job = getJob($jobDb,$sleepTime,$logger,$queue,$jobId,$taskId);
}

$logger->info("Real job exited in state... ".$job->getState());

#if state
if ($job->getState() eq $JOBSTATE->FAILED()){
   $logger->error("Job exited in failed state");
   exit(4);
}

exit(0);


# If we get a signal catch it and exit, but first notifiy Panfish by dropping a file
# in the deleted folder

# exit

#
# uses the JobDatabase to get the job kick.
# 
#
sub getJob {
   my $jobDb = shift;
   my $sleepTime = shift;
   my $logger = shift;
   my $queue = shift;
   my $jobId = shift;
   my $taskId = shift;

   my $job = $jobDb->getJobByQueueAndId($queue,$jobId,$taskId);
   if (!defined($job)){

       $logger->warn("Unable to find job : $queue,$jobId,$taskId.  Sleeping $sleepTime seconds before trying again");

       $job = $jobDb->getJobByQueueAndId($queue,$jobId,$taskId);

       if (!defined($job)){
           $logger->fatal("Unable to find job : $queue,$jobId,$taskId  : Exiting");
           exit(1);
       }    
   }
   return $job;
}


sub handleSignal {
    my $logger = shift;

    if ($SIGTERMCALLED == 1){
       $logger->fatal("TERM signal received.  Exiting...");
       exit(2);
    }
    if ($SIGUSR1CALLED == 1){
       $logger->fatal("USR1 signal received.  Exiting...");
       exit(3);
    }
}



1;

__END__

=head1 NAME

line - The shadow job run on local Grid Engine responsible for submission and monitoring of real job on Panfish Multicluster Grid Engine Wrapper

=head1 SYNOPSIS

line [ B<options> ]

=head1 DESCRIPTION

B<Line> is the shadow job submitted by B<cast> and is responsible for
submitting the real job to Panfish Multicluster Grid Engine Wrapper.  This
command also monitors the real job for completion.

The advantage of this design is the user can invoke standard Grid Engine
commands (qdel, qstat,etc.) on B<line> to administer the job.

B<NOTE:>  It is the responsibility of the caller to invoke B<land> to 
retrieve the data from the remote cluster once the job completes.

=head1 OPTIONS

Lots of options here

=over 4

=item B<-c command>

Defines the command to run.  This needs to be a bash shell script.

This B<command> must be a script file, its the last argument and must meet the following conditions:

=over 12

=item Any Grid Engine directives ie B<#$> in the B<command> script will be ignored.  Please use B<#$PANFISH> directives.

Z<>

=item B<Command> must be a bash script invoking commands and tools that can be run on any of the remote clusters.

Z<>

=item B<Command> must use B<PANFISH_BASEDIR> variable to prefix any paths.  A list of all environment variables that will be
set can be seen in the B<ENVIRONMENT VARIABLES> section below.

Z<>

=item B<Command> must NOT assume output from any other job enqueued or running in B<Panfish> will be available to it.

Z<>

=back

=item B<-e path,...>

Defines path of standard error stream.  
The following variables can be used in construction of the path and will be set appropriately:

=over 8

=item $USER       user ID of job owner

=item $JOB_ID     current job ID

=item $SGE_TASK_ID    array job task index number

Z<>

=back

This value can also be set within the B<command> using
the B<#$PANFISH> directive.

=item B<-o path,...>

Defines path of standard output stream.  See B<-e> description for allowed 
variables in B<path>  This value can also be set within the B<command> using
the B<#$PANFISH> directive.


=item B<-dir path>

Defines directory to upload to remote clusters.  B<Cast> will upload the contents of
this directory to all remote clusters in B<-q> queue list when set.  If not set no
upload operation is performed.  This value can also be set within the B<command> using
the B<#$PANFISH> directive.  

NOTE:  This is not an option in B<qsub>.

=item B<--verbose>

Verbose mode.  Causes B<cast> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 3.

NOTE:  This is not an option in B<qsub>.

=back

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
