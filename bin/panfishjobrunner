#!/usr/bin/perl

use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/perl5";
use lib "$Bin/../share/perl5";



use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;

if (@ARGV == 0){
  pod2usage(2);
}

my $verboseArg;
my $helpArg;
my $manArg;

my $cmdLineParseResult = GetOptions ("parallel=i" => \$parallelCommandsArg,
                                     "verbose+"       => \$verboseArg,
                                     "help|?"         => \$helpArg,
                                     "man"            => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

if (@ARGV < 1){
  pod2usage(2);
}

my $logger = Panfish::Logger->new();
my $reader = Panfish::FileReaderWriterImpl->new($logger);
$logger->setLevelBasedOnVerbosity($verboseArg);

my $commands = $ARGV[0];

my $res = $reader->openFile($commands);
if (defined($res)){
    $logger->fatal($res);
    exit(1);
}

my @cmdArray;
my $cmd = $reader->read();
while($cmd){
   chomp($cmd);
   push(@cmdArray,$cmd);
   $cmd = $reader->read();
}
$reader->close();

$logger->debug("Found ".@cmdArray." commands to run");

if (!defined($parallelCommandsArg)){
  $parallelCommandsArg = @cmdArray;
}
elsif ($parallelCommandsArg <= 0){
  $logger->fatal("Value passed to --parallel must be greater then 0");
  exit(1);
}

$logger->debug("Running $parallelCommandsArg commands at a time");

my %pidHash;
my $exitCode;
my $childFailed = 0;

for (my $x = 0; $x < @cmdArray;$x++){

   # create child process
   my $pid = fork();

   if (!defined($pid)){ # fork failed
       $logger->fatal("Resources not available to fork");
       exit(1); #figure this is bad so we will just bail
   }
   elsif($pid == 0){ # I am the child
       my $ret = system($cmdArray[$x]);
       exit($ret);
   }

   # if i am here I am the parent
   $pidHash{$pid} = $x; # just set the value to index of command in @cmdArray

   $logger->debug("Waiting for process id: $pid which corresponds to this command : ".$cmdArray[$x]);

   $jobFinished = 0;
   # Wait for jobs to finish if we have too many
   # running.
   while (keys(%pidHash) >= $parallelCommandsArg){
       for my $cpid ( keys %pidHash){
          if (waitpid($cpid,WNOHANG) != 0){
             $exitCode = $?;
             if ($exitCode != 0){
                $logger->error("Process $cpid : ".$cmdArray[$pidHash{$cpid}].
                               " : exited with nonzero exit code : $exitCode");
                $childFailed = 20;
             }
             delete $pidHash{$cpid};
             $jobFinished = 1;
          }
       }

       # if no jobs completed sleep 10 seconds before checking again
       if ($jobFinished == 0){
          sleep 10;
       }
   }
}

#only the parent reaches this

$logger->debug("No more commands to submit.  Waiting for children commands to complete");

#wait for any children threads to complete

for my $cpid (keys %pidHash){
  waitpid($cpid,0);
  $exitCode = $?;
  if ($exitCode != 0){
     $logger->error("Process $cpid : ".$cmdArray[$pidHash{$cpid}].
                    " : exited with nonzero exit code : $exitCode");
     $childFailed = 20;
  }
}

exit($childFailed);

1;

__END__

=head1 NAME

panfishjobrunner - Runs commands passed in via input file in parallel

=head1 SYNOPSIS

panfishjobrunner [ B<options> ] [ B<command file> ]

=head1 DESCRIPTION

B<Panfishjobrunner> takes a file containing commands and runs them in
parallel.  

B<Panfishjobrunner> simply runs each command as a child process and waits
for them to finish.

=head1 OPTIONS

As of now there are no options, but there should be :)

=over 4

=item B<--parallel #>

Defines number of commands to run in parallel.  If unset all the commands set in the command file
will be run in parallel.

=item B<--help>

Displays help.

=item B<--man>

Displays man page.

=item B<--verbose>

Verbose mode.  Causes B<panfishjobrunner> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 2.

=back

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
