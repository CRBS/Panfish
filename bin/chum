#!/usr/bin/perl


use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/../lib";
use lib "$Bin/../lib/perl5/site_perl";
use lib "$Bin/../lib/perl5";

use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::SSHExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::PanfishConfigFactory;
use Panfish::FileReaderWriterImpl;
use Panfish::FileUtil;
use Panfish::RemoteIO;
use Cwd;

if (@ARGV == 0){
  pod2usage(2);
}


my $cmdLineParseResult = GetOptions ("directory=s"   => \$directoryArgValue,
                                     "cluster=s"     => \$clusterArgValue,
                                     "exclude=s"     => \@excludeArgValues,
                                     "listchummed"   => \$listChummedArg,
                                     "retry=i"       => \$retryArgValue,
                                     "timeout=i"     => \$timeOutArgValue,
                                     "dry-run"       => \$dryRunArg,
                                     "verbose+"      => \$verboseArg,
                                     "help|?"        => \$helpArg,
                                     "man"           => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

if (!defined($directoryArgValue) ||
    ! -d $directoryArgValue){

   pod2usage(-message => "\nValid directory must be set via the --directory flag\n",
             -verbose => 1,
             -exitval => 2);

}

# NOT IMPLEMENTED ARGS
if (defined($timeOutArgValue)){
  print STDERR "-timeout flag not implemented yet.  Please omit this argument. Sorry.\n";
  exit(100);
}

if (defined($retryArgValue)){
  print STDERR "-retry flag not implemented yet.  Please omit this argument. Sorry.\n";
  exit(100);
}




my $logger = Panfish::Logger->new();

# sets the logging level based on number of times verbose flag 
# was passed into command
$logger->setLevelBasedOnVerbosity($verboseArg);

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$logger);
my $config = $configFactory->getPanfishConfig();
my $exec = Panfish::ForkExecutor->new();
my $sshExec = Panfish::SSHExecutor->new($config,$exec,$logger);
my $uploader = Panfish::RemoteIO->new($config,$sshExec,$logger);

my ($error,@clusterList) = $config->getClusterListAsArray($clusterArgValue);

my $fUtil = Panfish::FileUtil->new($logger);

# force auto flush for standard out
local $| = 1;

# if current dir is specified use it.
if ($directoryArgValue eq "."){
   $directoryArgValue = getcwd();  
}

# clean up the directory path
$directoryArgValue = $fUtil->standardizePath($directoryArgValue);

print "\nExamining ... $directoryArgValue";
my $startTime = time();
my ($numFiles,$numDirs,$numSymLinks,$sizeInBytes,$error) = $fUtil->getDirectorySize($directoryArgValue);

my $duration = time() - $startTime;

if (defined($error)){
   print " ... failed.  Took $duration seconds.\n";
   $logger->fatal("There was an error : $error");
   exit(1);
}

print " ... done.  Took $duration seconds.\n";


print "Found $sizeInBytes bytes in $numFiles files\n\n";

$logger->info("Directory to upload: $directoryArgValue");
$logger->info("# of Files:  $numFiles");
$logger->info("# of Directories:  $numDirs");
$logger->info("# of Symlinks:  $numSymLinks");
$logger->info("Size in Bytes:  $sizeInBytes");

if (defined($dryRunArg)){
   print "Dry run set, above path would be uploaded to: ";
   for (my $x = 0; $x < @clusterList; $x++){
      if ($clusterList[$x] ne $config->getThisCluster()){
           print " $clusterList[$x]";
      }
   }
   print "\n";
   exit(0);
}

my $chummedClusters = "";

for (my $x = 0; $x < @clusterList ; $x++){

    # skip this cluster cause the data does NOT need to be moved
    if ($clusterList[$x] eq $config->getThisCluster()){
        print "Skipping $clusterList[$x] cause this program is running on this cluster\n";
        
        if ($chummedClusters ne ""){
           $chummedClusters .= ",";
        }
        $chummedClusters .= $clusterList[$x];
        next;
    }
    
    print "Uploading to $clusterList[$x] ...";
    $startTime = time();
    $res = $uploader->upload($directoryArgValue,$clusterList[$x],\@excludeArgValues);
    if (defined($res)){
       print "failed.\n";
       $logger->fatal("Unable to upload $directoryArgValue to $clusterList[$x] : $res");
       exit(2);
    }
    $duration = time() - $startTime;

    if ($duration == 0){
       $duration = 1;
    }

    printf(" done.  Rate: %.2f Mb/sec.\n",(($sizeInBytes/1000000.0)/$duration));
    if ($chummedClusters ne ""){
        $chummedClusters .= ",";
    }
    $chummedClusters .= $clusterList[$x];
}

# used by automated programs that want to use all clusters
# so they know what clusters to download from.
if (defined($listChummedArg)){
   print "chummed.clusters=$chummedClusters\n";
}

exit(0);
1;

__END__

=head1 NAME

chum - Uploads directory to remote clusters

=head1 SYNOPSIS

chum [ B<options> ] 

=head1 DESCRIPTION

B<Chum> uploads a directory to remote clusters 

B<Chum> does this utilizing B<rynsc> to push the data to clusters
specified by the user or to call clusters configured in B<panfish.config>
file.

=head1 OPTIONS


=over 4

=item B<--directory path>

Defines the directory to upload.  Any symbolic links in this directory will be ignored.

=item B<--cluster cluster_list,..>

Defines the list of clusters (comma delimited) that the directory should be uploaded to.
If this argument is omitted then all clusters listed in B<panfish.config::queue.list> will
be used.  

=item B<--listchummed>

If set program will output a line listing what clusters the data was uploaded to.
The format of this output will be as follows:

chummed.clusters=CLUSTER1,CLUSTER2,CLUSTER3

=item B<--exclude PATTERN>

Defines file/dir pattern to exclude in transfer.  Works same as B<--exclude> in B<rsync>

=item B<--retry count>

Defines the number of times to retry the transfer per cluster before failing. Default is 10.


=item B<--timeout seconds>

Defines timeout in seconds this program should wait before attempting a retry if a transfer failed.
Default is 30 seconds.

=item B<--dry-run>

If set, the program will NOT transfer any data, instead the program will merely state what it 
would transfer.

=item B<--verbose>

Verbose mode.  Causes B<chum> to print debugging messages.  Multiple B<--verbose> options increase
verbosity.  The maximum is 2.

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
