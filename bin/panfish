#!/usr/bin/perl


use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/../lib";
use lib "$Bin/../lib/perl5/site_perl";
use lib "$Bin/../lib/perl5";

use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;
use Panfish::PanfishConfigFactory;
use Panfish::JobDatabase;
use Panfish::JobBatcher;
use Panfish::FileUtil;
use Panfish::SSHExecutor;
use Panfish::RsyncUploader;
use Panfish::JobBatchedChummer;
use Panfish::SSHJobSubmitter;
use Panfish::SSHJobWatcher;
use Panfish::QsubJobSubmitter;


my $cmdLineParseResult = GetOptions ("daemon=s"    => \$daemonArgValue,
                                     "cluster=s"   => \$clusterArgValue,
                                     "log=s"       => \$logArgValue,
                                     "help|?"      => \$helpArg,
                                     "man"         => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

my $logger = Panfish::Logger->new();

my $logFileHandle = undef;

if (defined($logArgValue)){
    open($logFileHandle,">$logArgValue") || die $!;
    $logger->setOutput($logFileHandle);
}

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $writer = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$logger);
my $config = $configFactory->getPanfishConfig();
$logger->setLevelBasedOnVerbosity($config->getPanfishVerbosity());
my $exec = Panfish::ForkExecutor->new();
my $fUtil = Panfish::FileUtil->new($logger);

my $exec = Panfish::ForkExecutor->new();
my $sshExec = Panfish::SSHExecutor->new($config,$exec,$logger);
my $uploader = Panfish::RsyncUploader->new($config,$exec,$sshExec,
                                           $logger);

my $jobDb;
my $batcher;
my $batchedChummer;
my $submitter;
my $watcher;
my @clusterList;
my $error;

# if no cluster is specified this daemon handles the shadow jobs and uses
# ssh to run jobs on remote clusters
#
if (!defined($clusterArgValue)){
    $jobDb = Panfish::JobDatabase->new($reader,
                                      $config->getSubmitDir(),$logger);
    $batcher = Panfish::JobBatcher->new($config,$jobDb,$logger,$fUtil,
                                       $reader,$writer);

    $batchedChummer = Panfish::JobBatchedChummer->new($config,$jobDb,
                                                     $logger,$fUtil,$uploader);

    $submitter = Panfish::SSHJobSubmitter->new($config,$jobDb,$logger,
                                           $fUtil,$sshExec);

    $watcher = Panfish::SSHJobWatcher->new($config,$jobDb,$logger,
                                       $fUtil,$sshExec);

    ($error,@clusterList) = $config->getClusterListAsArray();

    if (defined($error)){
        $logger->fatal("Problem getting cluster list : $error");
        exit(1);
    }

}
else {
    # the cluster is defined so we need to ignore batcher and batchedchummer
    # and make special versions of submitter and watcher to actually
    # run the jobs on the cluster
    $logger->info("Submitting jobs directly via qsub");
    $clusterList[0] = $clusterArgValue;
    $jobDb = Panfish::JobDatabase->new($reader,
                                      $config->getClusterJobDir($clusterArgValue),$logger);

    $submitter = Panfish::QsubJobSubmitter->new($config,$jobDb,$logger,$fUtil,$exec);
   
    $watcher = Panfish::SSHJobWatcher->new($config,$jobDb,$logger,
                                           $fUtil,$sshExec);
}


while(1 == 1){
  
    
   for (my $x = 0; $x < @clusterList ; $x++){
      if ($logger->isDebugEnabled() && !defined($clusterArgValue)){
          $logger->debug("$clusterList[$x] --".
                         $jobDb->getSummaryForCluster($clusterList[$x]));
      }
      
      if (defined($batcher)){
          $check = $batcher->batchJobs($clusterList[$x]);
      }
      
      if (defined($batchedChummer)){
          $check = $batchedChummer->chumBatchedJobs($clusterList[$x]);
      }
      
      $check = $submitter->submitJobs($clusterList[$x]);

      $check = $watcher->checkJobs($clusterList[$x]);
   }
   $logger->debug("sleeping X seconds");
   sleep 5;
}


$logger->info("Exit Code:  ".$exec->getExitCode());
exit($exitCode);
1;

__END__

=head1 NAME

panfish - Panfish Multicluster Grid Engine Wrapper daemon

=head1 SYNOPSIS

panfish [ B<options> ]

=head1 DESCRIPTION

B<Panfish> runs jobs submitted by B<cast> on remote clusters letting

=head1 OPTIONS

=over 4

=item B<--log path>

Defines path to a file to write output to.

=item B<--daemon>

Defines if B<panfish> should be run as a daemon or not

=item B<--verbose>

Verbose mode.  Causes B<cast> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 3.

NOTE:  This is not an option in B<qsub>.


=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
