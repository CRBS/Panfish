#!/usr/bin/perl

use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/perl5";
use lib "$Bin/../share/perl5";


use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;
use Panfish::PanfishConfigFactory;
use Panfish::FileJobDatabase;
use Panfish::JobBatcher;
use Panfish::FileUtil;
use Panfish::SSHExecutor;
use Panfish::RemoteIO;
use Panfish::JobBatchedChummer;
use Panfish::SSHJobSubmitter;
use Panfish::SSHJobWatcher;
use Panfish::QsubJobSubmitter;
use Panfish::QstatJobWatcher;
use Panfish::SubmitCommand;

use Panfish::PBSQsubParser;
use Panfish::SGEQsubParser;
use Panfish::SLURMSbatchParser;

use Panfish::JobHashFactory;
use Panfish::CurrentWorkingDirHashKeyGenerator;
use Panfish::PsubDirnameHashKeyGenerator;
use Panfish::PsubHashKeyGenerator;
use Panfish::PsubIdHashKeyGenerator;
use Panfish::FileLock;
use Panfish::SortByFileAgeSorter;

my $cmdLineParseResult = GetOptions ("daemon=s"     => \$daemonArgValue,
                                     "cluster=s"    => \$clusterArgValue,
                                     "log=s"        => \$logArgValue,
                                     "iterations=i" => \$iterationArgValue,
                                     "cron"        => \$cronArg,
                                     "help|?"       => \$helpArg,
                                     "man"          => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

my $logger = Panfish::Logger->new();

my $logFileHandle = undef;

if (defined($logArgValue)){
    open($logFileHandle,">$logArgValue") || die $!;
    $logger->setOutput($logFileHandle);
}


# if no cluster is specified this daemon handles the shadow jobs and uses
# ssh to run jobs on remote clusters
#
if (!defined($clusterArgValue)){
  pod2usage(-exitstatus => 1, -verbose => 1);
}

my $fUtil = Panfish::FileUtil->new($logger);

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$fUtil,$logger);
my $config = $configFactory->getPanfishConfig();
$logger->setLevelBasedOnVerbosity($config->getPanfishVerbosity());

my $fileAgeSorter = Panfish::SortByFileAgeSorter->new($fUtil);
my $writer = Panfish::FileReaderWriterImpl->new($logger);
my $exec = Panfish::ForkExecutor->new();
my $sshExec = Panfish::SSHExecutor->new($config,$exec,$logger);

my $lockFile = "";

# if cron flag was set verify this is the only instance of this program running
# by looking at the lock file
if (defined($cronArg) || defined($iterationArgValue)){
   my $scriptName = $0;
   $scriptName=~s/^.*\///;
   $lockFile = $config->getDatabaseDir($clusterArgValue)."/".$scriptName;

   $logger->debug("Looking for lock file $lockFile");
   my $fLock = Panfish::FileLock->new($logger,$fUtil,$exec,$reader);
   my $error = $fLock->create($lockFile,$$);
   if (defined($error)){
      $logger->fatal("Unable to create lock file : $error");
      exit(1);
   }

   if (!defined($iterationArgValue)){
      $iterationArgValue = 1;
   }
}

my $uploader = Panfish::RemoteIO->new($config,$sshExec,$logger);

my $jobDb = Panfish::FileJobDatabase->new($reader,$config->getDatabaseDir(),$fUtil,$logger);

my $curDirKeyGen = Panfish::CurrentWorkingDirHashKeyGenerator->new($logger);
my $curDirJobHashFac = Panfish::JobHashFactory->new($curDirKeyGen,$logger);

my $batcher = Panfish::JobBatcher->new($config,$jobDb,$logger,$fUtil,$reader,$writer,$curDirJobHashFac,$fileAgeSorter);

my $psubKeyGen = Panfish::PsubHashKeyGenerator->new($logger,$fUtil);

my $psubDirKeyGen = Panfish::PsubDirnameHashKeyGenerator->new($logger,$psubKeyGen,$fUtil);

my $psubDirJobHashFac = Panfish::JobHashFactory->new($psubDirKeyGen,$logger);

my $batchedChummer = Panfish::JobBatchedChummer->new($config,$jobDb,
                                                   $logger,$fUtil,$uploader,$psubDirJobHashFac,$fileAgeSorter);

my $psubJobHashFac = Panfish::JobHashFactory->new($psubKeyGen,$logger);

my $sshSubmitter = Panfish::SSHJobSubmitter->new($config,$jobDb,$logger,
                                           $fUtil,$sshExec,$psubJobHashFac,$fileAgeSorter);

my $psubIdKeyGen = Panfish::PsubIdHashKeyGenerator->new($logger,$psubKeyGen);

my $psubIdJobHashFac = Panfish::JobHashFactory->new($psubIdKeyGen,$logger);

my $sshWatcher = Panfish::SSHJobWatcher->new($config,$jobDb,$logger,
                                       $fUtil,$sshExec,$psubIdJobHashFac);

# TODO: move this into a factory
my $sParser;
if ($config->getEngine() eq "SGE"){
  $sParser = Panfish::SGEQsubParser->new();
}
elsif ($config->getEngine() eq "PBS"){
  $sParser = Panfish::PBSQsubParser->new();
}
elsif ($config->getEngine() eq "SLURM"){
  $sParser = Panfish::SLURMSbatchParser->new();
}
else {
   $logger->fatal("Engine ".$config->getEngine(). " not supported");
   exit(1);
}

my $submitCommand = Panfish::SubmitCommand->new($logger,$exec,$config->getSubmit(),$sParser,60,3,60);

my $qsubSubmitter = Panfish::QsubJobSubmitter->new($config,$jobDb,$logger,$fUtil,$submitCommand,$psubJobHashFac,$fileAgeSorter);

my $qstatWatcher = Panfish::QstatJobWatcher->new($config,$jobDb,$logger,
                                                 $fUtil,$exec);

my @clusterList;
my $error;

($error,@clusterList) = $config->getClusterListAsArray();

if (defined($error)){
    $logger->fatal("Problem getting cluster list : $error");
    $fUtil->removeLock("$0.lck");
    exit(1);
}


#double check cluster set in clusterArgValue is actually valid
($cError,@testClist) = $config->getClusterListAsArray($clusterArgValue);
if (defined($cError)){
   $logger->fatal("Cluster $clusterArgValue is not a valid cluster");
   $fUtil->removeLock("$0.lck");
   exit(1);
}

my $iterationCount = 1;

my $keepLooping = 1;

my $exitCode = 0;

# infinite loop broken only by signal or fatal error.
while($keepLooping == 1){
  
    
   for (my $x = 0; $x < @clusterList ; $x++){
      if ($logger->isDebugEnabled() && !defined($clusterArgValue)){
          $logger->debug("$clusterList[$x] --".
                         $jobDb->getSummaryForCluster($clusterList[$x]));
      }
      
      $check = $batcher->batchJobs($clusterList[$x]);
      
      $check = $batchedChummer->chumBatchedJobs($clusterList[$x]);
      
      # if this is the local cluster so lets see if we have to 
      # directly submit any jobs and check the status of any
      # local real jobs
      # otherwise remotely submit and check on status of jobs
      if ($clusterArgValue eq $clusterList[$x]){
          $check = $qsubSubmitter->submitJobs($clusterList[$x]);
          $check = $qstatWatcher->checkJobs($clusterList[$x]);
      }
      else {
          $check = $sshSubmitter->submitJobs($clusterList[$x]);
          $check = $sshWatcher->checkJobs($clusterList[$x]);
      }
   }

   if (defined($iterationArgValue)){
     if ($iterationCount >= $iterationArgValue){
        $logger->debug("IterationCount $iterationCount equals or exceeds $iterationArgValue exiting..");
        $keepLooping = 0;
     }
   }
   if ($keepLooping == 1){
       $logger->debug("Sleeping ".$config->getPanfishSleepTime());
       sleep $config->getPanfishSleepTime();
   }
   $iterationCount++;

}


$logger->info("Exit Code:  ".$exitCode);
$fUtil->removeLock($lockFile);
exit($exitCode);
1;

__END__

=head1 NAME

panfish - Panfish Multicluster Grid Engine Wrapper daemon

=head1 SYNOPSIS

panfish [ B<options> ]

=head1 DESCRIPTION

B<Panfish> runs jobs submitted by B<cast> on remote clusters letting

=head1 OPTIONS

=over 4

=item B<--cluster name>

Defines the cluster that this instance of B<panfish> is running on.

=item B<--log path>

Defines path to a file to write output to.

=item B<--daemon>

Defines if B<panfish> should be run as a daemon or not

=item B<--iterations val>

Defines number of iterations the program should examine all jobs.  If not set
the program will run in a loop forever.

=item B<--cron>

Cron mode.  This tells B<panfish> that the command should make sure no other instance
of B<panfish> is running by checking for a token file in the database.dir and if none 
is found to run 1 iteration and exit.  

=item B<--verbose>

Verbose mode.  Causes B<panfish> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 2.

NOTE:  This is not an option in B<qsub>.

=back

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
