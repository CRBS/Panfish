#!/usr/bin/perl


use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/../lib";
use lib "$Bin/../lib/perl5/site_perl";
use lib "$Bin/../lib/perl5";

use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::FileReaderWriterImpl;
use Panfish::PanfishConfigFactory;
use Panfish::JobDatabase;
use Panfish::JobBatcher;
use Panfish::FileUtil;
use Panfish::SSHExecutor;
use Panfish::RsyncUploader;
use Panfish::JobBatchedChummer;
use Panfish::SSHJobSubmitter;
use Panfish::SSHJobWatcher;
use Panfish::QsubJobSubmitter;
use Panfish::QstatJobWatcher;

my $cmdLineParseResult = GetOptions ("daemon=s"    => \$daemonArgValue,
                                     "cluster=s"   => \$clusterArgValue,
                                     "log=s"       => \$logArgValue,
                                     "help|?"      => \$helpArg,
                                     "man"         => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

my $logger = Panfish::Logger->new();

my $logFileHandle = undef;

if (defined($logArgValue)){
    open($logFileHandle,">$logArgValue") || die $!;
    $logger->setOutput($logFileHandle);
}


# if no cluster is specified this daemon handles the shadow jobs and uses
# ssh to run jobs on remote clusters
#
if (!defined($clusterArgValue)){
  pod2usage(-exitstatus => 1, -verbose => 1);
}

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $writer = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$logger);
my $config = $configFactory->getPanfishConfig();
$logger->setLevelBasedOnVerbosity($config->getPanfishVerbosity());
my $exec = Panfish::ForkExecutor->new();
my $fUtil = Panfish::FileUtil->new($logger);

my $exec = Panfish::ForkExecutor->new();
my $sshExec = Panfish::SSHExecutor->new($config,$exec,$logger);
my $uploader = Panfish::RsyncUploader->new($config,$sshExec,$logger);

my $jobDb = Panfish::JobDatabase->new($reader,$config->getDatabaseDir(),$logger);

my $batcher = Panfish::JobBatcher->new($config,$jobDb,$logger,$fUtil,$reader,$writer);

my $batchedChummer = Panfish::JobBatchedChummer->new($config,$jobDb,
                                                   $logger,$fUtil,$uploader);

my $sshSubmitter = Panfish::SSHJobSubmitter->new($config,$jobDb,$logger,
                                           $fUtil,$sshExec);

my $sshWatcher = Panfish::SSHJobWatcher->new($config,$jobDb,$logger,
                                       $fUtil,$sshExec);

my $qsubSubmitter = Panfish::QsubJobSubmitter->new($config,$jobDb,$logger,$fUtil,$exec);

my $qstatWatcher = Panfish::QstatJobWatcher->new($config,$jobDb,$logger,
                                                 $fUtil,$exec);

my @clusterList;
my $error;

($error,@clusterList) = $config->getClusterListAsArray();

if (defined($error)){
    $logger->fatal("Problem getting cluster list : $error");
    exit(1);
}


# infinite loop broken only by signal or fatal error.
while(1 == 1){
  
    
   for (my $x = 0; $x < @clusterList ; $x++){
      if ($logger->isDebugEnabled() && !defined($clusterArgValue)){
          $logger->debug("$clusterList[$x] --".
                         $jobDb->getSummaryForCluster($clusterList[$x]));
      }
      
      $check = $batcher->batchJobs($clusterList[$x]);
      
      $check = $batchedChummer->chumBatchedJobs($clusterList[$x]);
      
      # if this is the local cluster so lets see if we have to 
      # directly submit any jobs and check the status of any
      # local real jobs
      # otherwise remotely submit and check on status of jobs
      if ($clusterArgValue eq $clusterList[$x]){
          $check = $qsubSubmitter->submitJobs($clusterList[$x]);
          $check = $qstatWatcher->checkJobs($clusterList[$x]);
      }
      else {
          $check = $sshSubmitter->submitJobs($clusterList[$x]);
          $check = $sshWatcher->checkJobs($clusterList[$x]);
      }
   }
   $logger->debug("sleeping X seconds");
   sleep 5;
}


$logger->info("Exit Code:  ".$exec->getExitCode());
exit($exitCode);
1;

__END__

=head1 NAME

panfish - Panfish Multicluster Grid Engine Wrapper daemon

=head1 SYNOPSIS

panfish [ B<options> ]

=head1 DESCRIPTION

B<Panfish> runs jobs submitted by B<cast> on remote clusters letting

=head1 OPTIONS

=over 4

=item B<--cluster name>

Defines the cluster that this instance of B<panfish> is running on.

=item B<--log path>

Defines path to a file to write output to.

=item B<--daemon>

Defines if B<panfish> should be run as a daemon or not

=item B<--verbose>

Verbose mode.  Causes B<panfish> to print debugging messages.  Multiple B<--verbose> increase
verbosity.  The maximum is 2.

NOTE:  This is not an option in B<qsub>.


=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
