#!/usr/bin/perl


use FindBin qw($Bin);

#these allow this script to work when installed in alternate path
use lib "$Bin/../lib";
use lib "$Bin/../lib/perl5/site_perl";
use lib "$Bin/../lib/perl5";

use Getopt::Long;
use Pod::Usage;

use Panfish::ForkExecutor;
use Panfish::SSHExecutor;
use Panfish::PanfishConfig;
use Panfish::Logger;
use Panfish::PanfishConfigFactory;
use Panfish::FileReaderWriterImpl;
use Panfish::FileUtil;
use Panfish::RemoteIO;
use Cwd;

if (@ARGV == 0){
  pod2usage(2);
}


my $cmdLineParseResult = GetOptions ("directory=s"  => \$directoryArgValue,
                                     "cluster=s"    => \$clusterArgValue,
                                     "retry=i"      => \$retryArgValue,
                                     "timeout=i"    => \$timeOutArgValue,
                                     "dry-run"      => \$dryRunArg,
                                     "verbose+"     => \$verboseArg,
                                     "help|?"       => \$helpArg,
                                     "man"          => \$manArg) or pod2usage(2);


if ($helpArg){
  pod2usage(1);
}

if ($manArg){
  pod2usage(-exitstatus => 0, -verbose => 2);
}

if (!defined($directoryArgValue) ||
    ! -d $directoryArgValue){

   pod2usage(-message => "\nValid directory must be set via the --directory flag\n",
             -verbose => 1,
             -exitval => 2);

}

# NOT IMPLEMENTED ARGS
if (defined($timeOutArgValue)){
  print STDERR "-timeout flag not implemented yet.  Please omit this argument. Sorry.\n";
  exit(100);
}

if (defined($retryArgValue)){
  print STDERR "-retry flag not implemented yet.  Please omit this argument. Sorry.\n";
  exit(100);
}




my $logger = Panfish::Logger->new();

# sets the logging level based on number of times verbose flag 
# was passed into command
$logger->setLevelBasedOnVerbosity($verboseArg);

my $reader = Panfish::FileReaderWriterImpl->new($logger);
my $configFactory = Panfish::PanfishConfigFactory->new($reader,$logger);
my $config = $configFactory->getPanfishConfig();
my $exec = Panfish::ForkExecutor->new();
my $sshExec = Panfish::SSHExecutor->new($config,$exec,$logger);
my $downloader = Panfish::RemoteIO->new($config,$sshExec,$logger);

my ($error,@clusterList) = $config->getClusterListAsArray($clusterArgValue);

my $fUtil = Panfish::FileUtil->new($logger);

# force auto flush for standard out
local $| = 1;

# if current dir is specified use it.
if ($directoryArgValue eq "."){
   $directoryArgValue = getcwd();  
}

# clean up the directory path
$directoryArgValue = $fUtil->standardizePath($directoryArgValue);

for (my $x = 0; $x < @clusterList ; $x++){

    # skip this cluster cause the data does NOT need to be moved
    if ($clusterList[$x] eq $config->getThisCluster()){
        print "Skipping $clusterList[$x] cause this program is running on this cluster\n";
        next;
    }

    print "\nExamining path on $clusterList[$x]";
   
    my $startTime = time();

    my ($numFiles,$numDirs,$numSymLinks,$sizeInBytes,$error) = $downloader->getDirectorySize($directoryArgValue,
                                                                                             $clusterList[$x]);
    $duration = time() - $startTime;
    if (defined($error)){
       print " ... failed.  Took $duration seconds.\n";
       $logger->fatal("There was an error : $error");
       exit(1);
    }

    print " ... done.  Took $duration seconds.  ";
    print "Found $sizeInBytes bytes in $numFiles files\n\n";

    $logger->info("Directory to download: $directoryArgValue");
    $logger->info("# of Files:  $numFiles");
    $logger->info("# of Directories:  $numDirs");
    $logger->info("# of Symlinks:  $numSymLinks");
    $logger->info("Size in Bytes:  $sizeInBytes");

    if (defined($dryRunArg)){
          print "Dry run no action taken\n";
          next;
    }


    print "Downloading from $clusterList[$x] ...";
    $startTime = time();
    $res = $downloader->download($directoryArgValue,$clusterList[$x]);
    if (defined($res)){
       print "failed.\n";
       $logger->fatal("Unable to download $directoryArgValue to $clusterList[$x] : $res");
       exit(2);
    }
    $duration = time() - $startTime;

    if ($duration == 0){
       $duration = 1;
    }

    printf(" done.  Rate: %.2f Mb/sec.\n",(($sizeInBytes/1000000.0)/$duration));
}

exit(0);
1;

__END__

=head1 NAME

land - Downloads directory from remote clusters

=head1 SYNOPSIS

land [ B<options> ] 

=head1 DESCRIPTION

B<Land> downloads a directory from remote clusters.

B<Land> does this utilizing B<rynsc> to pull the data from clusters
specified by the user or to call clusters configured in B<panfish.config>
file.

=head1 OPTIONS


=over 4

=item B<--directory path>

Defines the directory to download.  

=item B<--cluster cluster_list,..>

Defines the list of clusters (comma delimited) that the directory should be downloaded from
If this argument is omitted then all clusters listed in B<panfish.config::queue.list> will
be used.  

=item B<--retry count>

Defines the number of times to retry the transfer per cluster before failing. Default is 3.


=item B<--timeout seconds>

Defines timeout in seconds this program should wait before attempting a retry if a transfer failed.
Default is 30 seconds.

=item B<--dry-run>

If set, the program will NOT transfer any data, instead the program will merely state what it 
would transfer.

=item B<--verbose>

Verbose mode.  Causes B<chum> to print debugging messages.  Multiple B<--verbose> options increase
verbosity.  The maximum is 3.

=head1 EXIT STATUS

=over

=item 0     Operation was successful.

=item >0    Error.

=back

=head1 EXAMPLES

=head1 FILES

 hello

=head1 AUTHOR

Christopher Churas <churas@ncmir.ucsd.edu>

=head1 REPORTING BUGS

bugs


=head1 COPYRIGHT

blah blah

=head1 SEE ALSO

more blah



=cut
